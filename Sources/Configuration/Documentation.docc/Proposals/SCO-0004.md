# SCO-0004: SecretMarkingProvider

Add a wrapper provider to mark configuration values as secrets based on key patterns.

## Overview

- Proposal: SCO-0004
- Author(s): [Gautam Raju](https://github.com/gautamrajur)
- Status: **Awaiting Review**
- Issue: [apple/swift-configuration#131](https://github.com/apple/swift-configuration/issues/131)
- Implementation:
    - [apple/swift-configuration#XX](https://github.com/apple/swift-configuration/pull/XX)

### Introduction

Add `SecretMarkingProvider`, a wrapper provider that marks configuration values as secrets based on key patterns, enabling post-hoc secret identification for providers that don't natively support it.

### Motivation

When integrating with external configuration sources, values may not be properly marked as secrets. This is common with:

- Environment variables from external systems
- Third-party configuration providers
- Legacy configuration files without secret metadata

Currently, `SecretsSpecifier` only works at provider initialization time. If you receive configuration from a provider you don't control, there's no way to mark specific values as secrets without implementing a custom wrapper.

For example, an `EnvironmentVariablesProvider` initialized without a `secretsSpecifier` will expose all values as non-secrets, including sensitive data like `DATABASE_PASSWORD` or `API_TOKEN`.

### Proposed solution

Add `SecretMarkingProvider<Upstream>`, a generic wrapper that:
1. Delegates all lookups to the upstream provider
2. Marks values as secrets when the key matches a user-provided predicate
3. Preserves existing secret status (never removes the `isSecret` flag)

```swift
let envProvider = EnvironmentVariablesProvider()

let secretMarkedProvider = SecretMarkingProvider(upstream: envProvider) { key in
    key.description.lowercased().contains("password") ||
    key.description.lowercased().contains("secret")
}

let config = ConfigReader(provider: secretMarkedProvider)
let dbPassword = config.string(forKey: "database.password") // marked as secret
```

Convenience methods on `ConfigProvider`:

```swift
// Predicate-based
let provider = envProvider.markSecrets { $0.description.contains("password") }

// Set-based
let provider = envProvider.markSecretsForKeys(["database.password", "api.key"])
```

### Detailed design

#### SecretMarkingProvider

A generic struct wrapping any `ConfigProvider`:

```swift
public struct SecretMarkingProvider<Upstream: ConfigProvider>: Sendable {
    private let isSecretKey: @Sendable (AbsoluteConfigKey) -> Bool
    private let upstream: Upstream

    public init(
        upstream: Upstream,
        isSecretKey: @Sendable @escaping (_ key: AbsoluteConfigKey) -> Bool
    )
}
```

Implements all `ConfigProvider` methods by delegating to upstream and marking results:
- `value(forKey:type:)` 
- `fetchValue(forKey:type:)`
- `watchValue(forKey:type:updatesHandler:)`
- `snapshot()`
- `watchSnapshot(updatesHandler:)`

#### SecretMarkedSnapshot

A private snapshot wrapper that applies the same secret-marking logic.

#### Convenience operators

Extensions on `ConfigProvider`:

```swift
extension ConfigProvider {
    func markSecrets(
        where isSecretKey: @Sendable @escaping (AbsoluteConfigKey) -> Bool
    ) -> SecretMarkingProvider<Self>

    func markSecretsForKeys(_ keys: Set<AbsoluteConfigKey>) -> SecretMarkingProvider<Self>
}
```

### API stability

This change is purely additive:
- New public type: `SecretMarkingProvider<Upstream>`
- New methods on `ConfigProvider`: `markSecrets(where:)`, `markSecretsForKeys(_:)`
- No changes to existing APIs

### Future directions

- Could integrate with `SecretsSpecifier` to provide a unified API for secret detection
- Could add logging/metrics for when secrets are marked

### Alternatives considered

1. **Extend SecretsSpecifier to work post-hoc** - Would require significant changes to the provider protocol and existing implementations.

2. **Add secret marking to ConfigReader** - Would only work at the reader level, not propagated through snapshots or watch sequences.

3. **Document the workaround** - Users could implement their own wrapper, but this is boilerplate that the library should provide.

