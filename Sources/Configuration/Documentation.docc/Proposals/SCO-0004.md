# SCO-0004: ExpressibleByConfigInt conversions

Let configuration readers convert integer-backed values into richer domain types using the new `ExpressibleByConfigInt` protocol.

## Overview

- Proposal: SCO-0004
- Author(s): [Blazej Sleboda](https://github.com/Adobels)
- Status: **Ready for Implementation**
- Issue: [apple/swift-configuration#96](https://github.com/apple/swift-configuration/issues/96)
- Implementation:
    - [apple/swift-configuration#135](https://github.com/apple/swift-configuration/pull/135)

### Introduction

Add an integer-focused counterpart to `ExpressibleByConfigString` so that `ConfigReader` can automatically convert numeric configuration values into enums, `Duration`, and other higher-level domain types.

### Motivation

Swift Configuration already supports transparent string-to-type conversions through `ExpressibleByConfigString` and `RawRepresentable<String>`. 

Many configuration values are expressed as integers instead: timeout durations in seconds, feature weights, enum ordinals, or version numbers. 
Today, adopters need to read the integer and convert it manually or introduce fragile helper APIs per type. 

Adding a first-class conversion hook for integers unlocks:

- **Duration support** – helpers can now use `config.int(forKey:as: Duration.self)` instead of reimplementing duration parsing.
- **Safer enums** – `RawRepresentable<Int>` enums get the same ergonomic `as:` conversions string-backed enums already enjoy.
- **Custom domain types** – adopters can wrap strongly-typed concepts (for example, `RetryBudget`, `APIVersion`, `Percent`) without new reader overloads.

### Proposed solution

Introduce a new protocol:

```swift
@available(Configuration 1.0, *)
public protocol ExpressibleByConfigInt: CustomStringConvertible {
    init?(configInt: Int)
}
```

`ConfigReader` and `ConfigSnapshotReader` already funnel typed conversions through helper functions generated by `gyb`. 
We extend those helpers so that integer-access APIs (`int`, `requiredInt`, `intArray`, `fetchInt`, `watchInt`, etc.) accept any type conforming to `ExpressibleByConfigInt`. 

The proposal also includes:

- A built-in conformance for `Swift.Duration`, interpreting the integer as seconds.
- Documentation for the new protocol alongside code samples that mirror the existing string-based guidance.

### Detailed design

1. **Protocol and documentation**
   - Add `ExpressibleByConfigInt.swift`, mirroring the structure of `ExpressibleByConfigString.swift`.
   - Require conforming types to provide a failable `init?(configInt:)` and a `description` used by access reporters.
   - Document the protocol in the DocC reference catalog and update the “Choosing reader methods” guide with string/int conversion sections that share the same structure.

2. **Reader extensions**
   - Extend the `ConfigReader` and `ConfigSnapshotReader` helper methods generated by `Scripts/gyb_utils.py` so every integer-based accessor has overloads that accept `Value: ExpressibleByConfigInt`.
   - Ensure higher-level APIs such as `fetch`, `watch`, and array overloads participate so provider authors get full coverage without extra work.

3. **Built-in conformances**
   - Conform `Swift.Duration` to `ExpressibleByConfigInt`. A positive integer maps to the equivalent `.seconds` duration; invalid values return `nil`.
   - Leverage existing `RawRepresentable<Int>` handling so enums continue to work without extra code.

4. **Guidance and samples**
   - Update the main documentation landing page to list both protocols.
   - Add cookbook-style snippets showing how to implement custom wrappers (for example, `APIVersion`) and how to call `config.int(forKey:as:)`.

The implementation is additive and compiles on the same platforms as the rest of the package.

### API stability

The change is purely additive:

- New protocol + `Duration` conformance.
- New overloads on existing APIs that preserve the current behavior when `as:` is omitted.
- No existing source is required to change; adopters opt in incrementally.

### Future directions

- Add more built-in conformances, based on community demand.

### Alternatives considered

- **Status quo** – keep requiring manual conversions or helper methods after reading integers. Rejected because it would keep int-based accessors in a less favorable place compared to the existing string conversions.
